---
layout: post
title: "when-let maybe?"
date: 2010-12-07T13:50:00-08:00
comments: false
categories:
 - Clojure
---

<div class='post'>
In this post we will see how to incrementally develop a macro similar to <a href="http://clojuredocs.org/clojure_core/clojure.core/when-let">when-let </a>but more flexible. <br /><br /><br />When-let is useful to both bind one variable and do a test on the bind value in one operation. One common usage is:<br /><br /><pre class="brush: clojure" name="code">(when-let [something (get-something arg1 arg2)]<br />&nbsp;&nbsp; (do-stuff something))</pre><br /><br />This is equivalent to this code:<br /><br /><pre class="brush: clojure" name="code">(let [something (get-something arg1 arg2)]<br />&nbsp;&nbsp; (when something<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (do-stuff something)))<br /></pre><br />but with a more concise form.<br /><br />When-let only <b>executes the code</b> after the binding if the value assigned in the let form is logically true, that is <b>only if the value is not nil or false</b>. In our example, this means that if <i>get-something</i> returns false then <i>do-stuff</i> will not be executed. Sometimes this is not enough and we want to execute the code even for false values. For instance if we are getting our data from a database and false values are acceptable but nil values are not, or if our functions return nil on error. <br /><br />We could define a when-nlet macro which does what when-let does but executes the body whenever the binded value is not nil. By spying the code from <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj#L1625">clojure.core</a> we obtain:<br /><br /><pre class="brush: clojure" name="code">(defmacro when-nlet [bindings &amp; body]<br />&nbsp; (when (not= (count bindings) 2)<br />&nbsp;&nbsp;&nbsp; (throw (IllegalArgumentException.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "when-nlet requires an even number of forms in binding vector")))<br />&nbsp; (let [form (bindings 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tst (bindings 1)]<br />&nbsp;&nbsp;&nbsp; `(let [temp# ~tst]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (when (not (nil? temp#))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let [~form temp#]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~@body)))))<br /></pre><br />This is fine. But what if we need multiple values to be bound and multiple checks on them?<br /><br />We could write:<br /><br /><pre class="brush: clojure" name="code">(when-nlet [val1 (get-something arg1 arg2)]<br />&nbsp; (when-nlet [val2 (get-something2 val1)]<br />&nbsp;&nbsp;&nbsp;&nbsp; (when-nlet [val3 (get-something3 val2]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (do-stuff val1 val2 val3))))<br /></pre><br />This is not satisfying. What about writing a when-nlet* macro that does multiple binds? <br /><br />We could call it like that:<br /><br /><pre class="brush: clojure" name="code">(when-nlet* [val1 (get-something arg1 arg2)<br />             val2 (get-something2 val1)<br />             val3 (get-something3 val2)]<br />          (do-stuff val1 val2 val3))<br /></pre><br />and it would produce multiple calls to when-nlet.<br /><br />Here it is:<br /><br /><pre class="brush: clojure" name="code">(defmacro when-nlet* [bindings &amp; body]<br />&nbsp; (when (not (even? (count bindings)))<br />&nbsp;&nbsp;&nbsp; (throw (IllegalArgumentException.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "when-nlet* requires an even number of forms in binding vector")))<br />&nbsp; (let [whenlets (reduce (fn [sexpr bind]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let [form (first bind)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tst (second bind)]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (conj sexpr `(when-nlet [~form ~tst]))))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (partition 2 bindings))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body (cons 'do body)]<br />&nbsp;&nbsp;&nbsp; `(-&gt;&gt; ~body ~@whenlets)))<br /></pre><br />After the reduce the <i>whenlets</i> variable is assigned this list (we can see it by playing with macroexpand, macroexpand-1 and prn at the REPL):&nbsp; <br /><br /><pre class="brush: clojure" name="code">((when-nlet [val3 (get-something3 val2)]) (when-nlet [val2 (get-something2 val1)]) (when-nlet [val1 (get-something arg1 arg2)]))<br /></pre><br />We then thread the body inside the <i>when-nlets</i> forms with the powerful <a href="http://clojuredocs.org/clojure_core/clojure.core/-%3E%3E">-&gt;&gt;</a> macro. We obtain:<br /><br /><pre class="brush: clojure" name="code">(when-nlet [val1 (get-something arg1 arg2)]<br />  (when-nlet [val2 (get-something2 val1)]<br />    (when-nlet [val3 (get-something3 val2)]<br />      (do (do-stuff val1 val2 val3)))))<br /></pre><br />So basically what we have done is creating a macro that does multiple binds, stops after the first bind returning a nil value and executes its body if no nil value has been encountered. It is nice and it shows us how much powerful Clojure is but... if we read this <a href="http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/">tutorial</a> on how to use <a href="http://min.us/mbv5B0RWqYQTcI">monads</a> in Clojure we quickly see that there is a simpler way to do the same thing with the maybe monad!<br /><br /><pre class="brush: clojure" name="code">(domonad maybe-m [val1 (get-something "a" "b")<br />                  val2 (get-something2 val1)<br />                  val3 (get-somnil val2)]<br />               (do-stuff val1 val2 val3))<br /></pre><br />This code is equivalent to our usage of when-nlet*. Thus, if we still feel the need for our when-nlet* macro, we could write it simply like that (after :using <a href="http://richhickey.github.com/clojure-contrib/monads-api.html">clojure.contrib.monads</a>):<br /><br /><pre class="brush: clojure" name="code">(defmacro when-nlet* [binding &amp; body]<br />  (let [body (cons 'do body)]<br />   `(domonad maybe-m ~binding ~body)))<br /></pre><br />Is that not much better?<br /><br />Conclusion: we shall not write macros before learning more about monads ;-) !</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
You&#39;re using the &quot;fn*&quot; convention precisely opposite to how most people do in Clojure.<br /><br />Usually, the asterisk suffix is used on a helper _function_ that is paired with a macro (with no suffix) that is only sugar around the function.</div>
</div>
<div class='comment'>
<div class='author'>Nicolas</div>
<div class='content'>
Very nice. This is the Maybe monad in Haskell, the Maybe type being defined as such:<br /><br />data Maybe a = Just a | Nothing<br />Just and Maybe are the constructors of the Maybe type. This is close to a C++ template on &lt;a&gt;, really.<br /><br />The do macro can be used to chain operations:<br /><br />maybeM = do<br />        val1 &lt;- getSomething &quot;a&quot; &quot;b&quot;<br />        val2 &lt;- getSomething2 val1<br />        val3 &lt;- getSomnil val2<br />        doStuff val1 val2 val3<br /><br />Each one of these function must return a Maybe type, constructed with &quot;Nothing&quot;, or &quot;Just 42&quot; for instance. To simplify things, let&#39;s just say that the arrow is an extraction of the internal Maybe value. val1 will be an Int, or a String, for example. Not a Maybe Int or Maybe String.<br /><br />There is another way to write this do program:<br /><br />maybeM = getSomething &quot;a&quot; &quot;b&quot;<br />        &gt;&gt;= \val1 -&gt; getSomething2 val1<br />        &gt;&gt;= \val2 -&gt; getSomnil val2<br />        &gt;&gt;= \val3 -&gt; doStuff val1 val2 val3<br /><br />&gt;&gt;= looks like a funnel, and behaves sort of like the unix pipe: take the result of the function getSomething &quot;a&quot; &quot;b&quot;, and if you can extract it from a Maybe type, pipe it into the lambda function that takes 1 parameter (val1). If the return is Nothing, then we can&#39;t extract anything and stop the evaluation there.<br /><br />This is why monads are needed to do I/O in Haskell: I/O functions return an action; executing it produces the new state of the world and has an I/O side-effect.<br /><br />People start using Javascript on the server now using Node.JS with a lot of asynchronous functions; they write code like:<br /><br />getSomething(&quot;a&quot;, &quot;b&quot;, function(val1) {<br />    getSomething2(va11, function(va2){<br />        getSomnil(val2, function(val3) {<br />            doStuff(val1, val2, val3); // wtf.<br />        });<br />    });<br />});<br /><br />This must be horrible to anyone who has been introduced to monads.</div>
</div>
</div>
