---
layout: post
title: "Dear language designers, do not forget Ada"
date: 2011-05-08T12:40:00-07:00
comments: false
categories:
 - Ada
 - Clojure
---

<div class='post'>
These last days I took some time to refresh my old memories of the Ada language. While Ada, like all languages, has defaults on its own I'm still very impressed by some functionalities it offers and that current mainstream languages still don't have. Most of these functionalities are there since the first standardized version in 1983 (since then the language standard was extended in 1995, 2005 and the next version is expected for 2012).<br /><br />The first impressive future is about primitive types. Here are some of the types defined in Ada and their C equivalent (taken from <a href="http://www.blogger.com/post-create.g?blogID=7938563989400397004#foot1">[1]</a>):<br /><br /><table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups"><colgroup><col align="left"></col><col align="left"></col><col align="left"></col> </colgroup><thead><tr><th>Ada Type</th><th>Description</th><th>C Equivalent</th></tr></thead> <tbody><tr><td>Character</td><td>A single character</td><td>char</td></tr><tr><td>Integer</td><td>An integer (32-bit) number</td><td>int</td></tr><tr><td>Natural</td><td>Zero or positive integer</td><td>-</td></tr><tr><td>Positive</td><td>A positive integer</td><td>-</td></tr><tr><td>Long_Integer</td><td>A big integer (same as long in Gcc)</td><td>long (same as int in Gcc)</td></tr><tr><td>Long_Long_Integer</td><td>A really big (64-bit) integer</td><td>long long</td></tr><tr><td>Short_Integer</td><td>A small (16-bit) integer</td><td>short</td></tr><tr><td>Short_Short_Integer</td><td>A really small (8-bit) integer</td><td>char</td></tr><tr><td>Float</td><td>A real number</td><td>float</td></tr><tr><td>Long_Float</td><td>A big real number</td><td>double</td></tr><tr><td>Long_Long_Float</td><td>A really big real number</td><td>long double</td></tr><tr><td>Short_Float</td><td>A smaller real number</td><td>?</td></tr><tr><td>Fixed</td><td>A fixed-point real number</td><td>-</td></tr><tr><td>String</td><td>An Ada fixed-length string</td><td>char array</td></tr></tbody> </table><br />Boolean types are also provided. New types are defined and type safety is guaranteed. Here we define a new type based on a Long_Float and a variable of this type:<br /><pre class="brush:Clojure" name="code">type Speed is new Long_Float;<br /><br />Speedy_Gonzales_Speed : Speed;<br /></pre><br />Since Speed is a new type, it is not a Long_Float and thus assignment from a Long_Float value to a Speed variable is forbidden:<br /><pre class="brush:Clojure" name="code">X : Long_float := 300.0; <br />Speedy_Gonzales_Speed := X;<br /></pre>The compiler effectively gives an error:<br /><code><br />expected type "Speed" defined at line 6<br />found type "Standard.Long_Float"<br /></code><br />When it makes sense, we can define a subtype of another primitive type. Assignments between types and their subtypes is allowed. Here we define the type Degree which is a subtype of Float:<br /><pre class="brush:Clojure" name="code">subtype Degree is Long_Float;<br /><br />Oven_Temperature : Degree;<br />Y : Long_Float := 255.0;<br /><br />Oven_Temperature := Y;<br /></pre><br />Types can be constrained with a range definition (taken from <a href="http://www.blogger.com/post-create.g?blogID=7938563989400397004#foot2">[2]</a>):<br /><pre class="brush:Clojure" name="code">type Degrees is new Float range -273.15 .. Float'Last;<br /></pre><br />This allow a Degrees variable to range from -273.15 (absolute zero) to the last value allowed by a Float.<br /><br />This strong typing provides safety and contrasts with what is seen in current mainstream programming languages. Languages like Java don't provide rich primitive types (there are for instance no unsigned integer in Java!) and require the programmer to define its own cumbersome classes if he wants new types (which poses readability problems if the types are new number types and the language does not support operator overloading). Some languages like C don't even bother so much about type conversion: a float can be assigned to an integer. This leads to solutions which are far from being satisfying (see for instance <a href="http://c-faq.com/fp/round.html">C FAQ - round</a>).<br /><br />A lot of other possibilities are offered to the Ada programmer, for instance decimal types can be defined with their precision. The precision is then guaranteed by the compiler:<br /><pre class="brush:Clojure" name="code">type money is delta 0.01 digits 18;<br /></pre>Ada also supports multidimensional arrays, bit-level memory access, definition of memory pool, concurrency programming in a task-oriented way, object-oriented programming, generic packages etc.<br /><br />At another level Scheme and Common Lisp supports a numeric towel. For example, 3 is an integer. Therefore 3 is also a rational, a real, and a complex (example from the <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2.1">Scheme standard</a>).<br /><br /><pre class="brush:Clojure" name="code">;; in Scheme:<br />&gt; (rational? (/ 1 5))<br />#t<br />&gt; (rational? 3)<br />#t<br />> (real? 3)<br />#t<br /></pre>While this discussion may not make so much sense for dynamic languages such as Clojure, I think new languages being designed, which are not dynamically typed, could really benefit of having such rich primitives types. A complex type systems like the one from ML or Haskell is not needed for this purpose and primitives types is the most basic and most used feature of a programming language, so dear languages designers, next time, have a small thought for Ada.<br /><br />[1] <a href="http://www.pegasoft.ca/resources/boblap/book.html" id="foot1"> http://www.pegasoft.ca/resources/boblap/book.html</a><br />[2] <a ahref="http://en.wikibooks.org/wiki/Ada_Programming" href="http://www.blogger.com/post-create.g?blogID=7938563989400397004" id="foot2">http://en.wikibooks.org/wiki/Ada_Programming</a></div>
