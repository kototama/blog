---
layout: post
title: "Tail recursion and function composition"
date: 2009-11-08T06:07:00-08:00
comments: false
categories:
 - Clojure
---

<div class='post'>
The chapter four of the <a href="http://www.paulgraham.com/acl.html">ANSI Common Lisp</a> book has an interesting code to insert a node in a <a href="http://en.wikipedia.org/wiki/Binary_search_tree">binary search tree (BST)</a>. The code, ported to Clojure, is:<br /><br /><pre class="brush: clojure" name="code">(defstruct node :elt :l :r)<br /><br />(defn bst-insert [bst x comp]<br />  (if (nil? bst)<br />    (struct node x)<br />    (let [elt (:elt bst)]<br />      (if (= x elt)<br />        bst<br />        (if (comp x elt)<br />          (struct node<br />                  elt<br />                  (bst-insert (:l bst) x comp)<br />                  (:r bst))<br />          (struct node<br />                  elt<br />                  (:l bst)<br />                  (bst-insert (:r bst) x comp)))))))<br /><br /></pre><br />The function is non-destructive. Creating a BST can be done like this: <br /><br /><pre class="brush: clojure" name="code">(def nums (reduce (fn [acc x] (bst-insert acc x &lt;)) nil [5 8 4 2 1 9 6 7 3]))<br /></pre>Obviously the function does not use a tail recursion. The value of the recursive call to <verbatim>bst-insert</verbatim> is used by the <verbatim>struct</verbatim> function.   How could we transform it to have a tail recursion? We need to store on a stack the information gained while doing the recursion: the branches we have visited and the branches taken. We store the information while we go from the root to the leaf. We can then unstack and reconstruct the tree from the leave to the root. This is done in the <verbatim>bst-insert-tc</verbatim> function:  <br /><pre class="brush: clojure" name="code">(defn bst-insert-tc [bst x comp]<br />  (loop [bst bst<br />         acc '()]<br />    (if (nil? bst)<br />      (loop [tree (struct node x)<br />             stack acc]<br />        (let [[lr elt branch] (first stack)]<br />          (if (empty? stack)<br />            tree<br />            (if (= lr :l)<br />              (recur (struct node elt branch tree) (rest stack))<br />              (recur (struct node elt tree branch) (rest stack))))))<br />      (let [elt (:elt bst)]<br />        (if (= x elt)<br />          bst<br />          (if (comp x elt)<br />            (recur (:l bst) (cons [:r elt (:r bst)] acc))<br />            (recur (:r bst) (cons [:l elt (:l bst)] acc))))))))<br /><br /></pre>This approach works but is a bit naive and the second loop can be simplified by using reduce:   <br /><pre class="brush: clojure" name="code">(defn bst-insert-tc2 [bst x comp]<br />  (loop [bst bst<br />         acc '()]<br />    (if (nil? bst)<br />      (reduce (fn [tree [lr elt branch]]<br />                (if (= lr :l)<br />                  (struct node elt branch tree)<br />                  (struct node elt tree branch)))<br />              (struct node x)<br />              acc)<br />      (let [elt (:elt bst)]<br />        (if (= x elt)<br />          bst<br />          (if (comp x elt)<br />            (recur (:l bst) (cons [:r elt (:r bst)] acc))<br />            (recur (:r bst) (cons [:l elt (:l bst)] acc))))))))<br /></pre>Once I had the first tail recursive version, I asked my friend <a href="http://journal.batard.info/">Yogi</a> how he would transform the <verbatim>bst-insert</verbatim> code into a tail recursive version. He did find a really elegant <a href="http://journal.batard.info/post/2009/11/05/bst">solution</a>, in Haskell. Here is the idea: instead of stacking information about the tree and then performing at the end calls to reconstruct the tree in reverse order, we can build a function constructing a new tree as we go from the root to the leaf.   When we are on a node, what we do is something like that (if the element to be inserted is smaller than the node's element):  <br /><pre class="brush: clojure" name="code">(struct node elt l (:r bst))<br /></pre>The problem is, when we are doing this operation, we do not know the value of <verbatim>l</verbatim>. <verbatim>l</verbatim> is a tree to be construct, and we can know its value only by doing a new recursive call. Since we do not know the value of it at this time, we will created an anonymous function that will be able to take this value as an argument later, when the value will be known. We thus construct anonymous functions at each level of the recursion, composing them into a unique function with <a href="http://clojure.org/api#toc151">comp</a>. Each anonymous function will return the appropriate tree for the left or right branches. At the end of the recursion, we know all the arguments. The last argument is the value of the element to be inserted. We can directly call the composed function which will create the whole tree. We do not even need to unstack anything:   <br /><pre class="brush: clojure" name="code">(defn bst-insert-tc3 [bst x cmp]<br />  (loop [bst bst<br />         f identity]<br />    (if (nil? bst)<br />      (f (struct node x))<br />      (let [elt (:elt bst)]<br />        (if (= x elt)<br />          bst<br />          (if (cmp x elt)<br />            (recur (:l bst) (comp f (fn [l] (struct node elt l (:r bst)))))<br />            (recur (:r bst) (comp f (fn [r] (struct node elt (:l bst) r))))))))))<br /></pre>The code shows how functional programming can be both elegant and efficient.  <br />The full code for the BST is available <a href="http://github.com/kototama/ansicommonlisp-book-clojure/blob/master/ch04/bst.clj"><bold>here</bold></a></div>
