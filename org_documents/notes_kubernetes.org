#+TITLE: Notes on Kubernetes
#+TAGS: kubernetes
#+CATEGORY: note

* Concepts

** Pods
The execution environment running containers. Usually one pod runs one container but sometimes more ("sidecar" container, for example for logging).
It's the minimal entity managed by Kubernetes. Pod have properties such as ~nodeSelector~, ~priority~, ~restartPolicy~ etc.
~restartPolicy=always~ does NOT restart failed or stopped pod, this is the job of Deployment.
** Initcontainer and Sidecar container
sidecar container is an initContainer with ~restartPolicy~ set to ~Always~
** Jobs and cronjob
A job is a pod with ~restartPolicy=never~. Backup, batch processing etc. ~ttlSecondsAfterFinished~ to clean
up. ~completion~ and ~parallelism~ parameters. Ex: ~kubectl create job onejob --image=busybox -- date~

CronJob schedule uses crontab syntax.
- Create with ~kubectl create cronjob myjob --image=busybox --schedule="*/1 * * * *" -- date~
- Test with ~kubectl create job myjob --from=cronjob/mycronjob~ will execute the job
- Clean with ~kubectl delete cronjobs.batch jobname~
** Deployments

Controller that manages the pod. Starts all the pods at the same time.
Self-healing, scaling, rollouts, and rollbacks.

- StatefulSet for stateful application, DaemonSet to run one application on each cluster node (unless node is "tainted"), Autoscaling.
- ReplicaSet used to scale Application.
- ~updateStrategy~ to deploy without downtime

*** Labels and selectors
- key-value commonly used in Kubernetes
- ~kubectl create deploy~ automatically get the label ~app=deploymentname~
- Labels connect different objects: deployments to pods, services to pod
- A ~selector~ is used to specify which label to track. ~--selector~~ on the CLI
- ~kubectl label~ to set labels  
- ~kubectl label ... <label>-~ with ~-~ at the end to remove a label
- ~kubectl create deploy notes --image=nginx --dry-run=client -o yaml~
- ~kubectl get deploy notes -o yaml~: annotations store the last applied configuration  
- ~kubectl annotate deploy <name> newnote="blabla"~

Example:
#+BEGIN_SRC yaml
  selector:
    matchLabels:
      app: webapp
#+END_SRC
*** Scaling manually
- ~kubectl deploy .. --replicas=3~
- ~kubectl scale deploy scaledapp --replicas=2~
    
*** Application updates
- ~strategy.type.rollingUpdate~: different version of the application might runned at the same time
- ~strategy.type.recreate~: don't support offering multiple versions simultaneously, so all applications are first down
- ~maxSurge~: number or percentage of app that can be added above the regular number
- ~maxUnavailable~: how many can be temporarly unavailable 

*** How deployment works
A new ReplicaSet is created. Old replica kept in case of rollback but with number of Pods set to 0.


*** StatefulSet
Maintains the identity of Pods, even if restarted. Use when one of the following is required:
- stable, unique network identifiers
- stable, persisten storage
- ordered, graceful deployment and scaling
- ordered and automated rolling update

- Persistent Pod names and DNS names, volume bindings
- Pods created and destroyed one at a time by default (can be changed), useful for some services like distributed databases
- Headless Service = a Service without a ClusterIP
- An Headless Service + StatefulSet = Governing Service
- Governing service creates DNS entries SRV and A for matching (label selector) pods


- Storage must use PersistentVolume and use ~volumeClaimTemplate~ which generates a PVC.
- Deleting a StatefulSet does not delete the volumes. Requires a headless Service.
- Pods are created one by one

*** DaemonSet
Starts one Pod instance on eahc Node in the cluster. Useful for log agents for example.

*** Autoscalling
HorizontalPodAutoscaler observes usage statistics. Metrics Server.
Example: ~kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10~

** Services and Networking

Networking in kubernetes: external net (the physical net), clusternet and podnet. Services route traffic to
the selected pods.

- ~ClusterIP~ service type, only internally accessible.
- ~NodePort~ creates an externally accessible port (high port only).
- ~LoadBalancer~
- ~ExternalName~ works on DNS name, useful for migration
- ~Headless~ direct communication between Pods, for StatefulSet


Services are round-robing traffic. Set of pods targeted by a Service depends of the ~selector~.
~kube-controller-manager~ scan for Pods that matches the selector. So one ~Service~ can provide access to Pods
in multiple ~Deployments~.

Commands: ~kubectl expose deployment NAME --port=80~ and ~kubectl create service~.

- ~targetPort~ the port on the application
- ~port~ the port on which the Service is accessible
- ~nodePort~ the port exposed externally while using the ~NodePort~ Service type

Ingress and GatewayAPI are only for HTTP-based services.

Exposed Services automatically registers to ~servicename.namespace.svc.clustername~.

Pods can always communicate, even if they are in other Namespaces. Limit traffic can be done with
NetworkPolicies.

NetworkPolicies have three different identifiers:
- podSelector
- namespaceSelector
- ipBlock

Gateway API provides routting and traffic management policies not addressed by Ingress: TCP, UDP, gRPC,
traffic splitting, mirroring, websockets.

Istio is a service mesh and facilitates managing complex relations between applications: traffic management,
security, observability for service-to-service communication

** Ingress and Gateway API
Reverse HTTP proxy. Gateway API is the successor of Ingress. Do not use both on the same machine.
- The load balancer is implemented by the Ingress controller
- Ingress uses Services to connect Pods that are used a service endpoint
- LoadBalancer have a 1:1 mapping from LoadBalancer to a service, so one LoadBalancer is needed per service

Ingress exposes HTTP and HTTPS resources. Traffic is controlled with rules.
- give Services externally-reachable
- load balance traffic
- terminate SSL/TLS

Common Ingress controllers: nginx, haproxy, traefik, kong, contour.

Ingress rules: ~pathType~ Exact or Prefix. Load balance on a single Service, as simple fanout or named-based
virtual hosting.

Gateway API use API resources provided by CRD (CustomResourceDefinitions). GatewayClass represents the Gateway
controller. The controller must be installed, like for Ingress. Before installing it, it's necessary to
install the Custom Resource.

** Service discovery

- Automatic. ClusterDNS registers a new A and SRV records when a new Service is created. SRV record have IP and
a PORT.
- ClusterIPs are on a separate network, no route to it
- ClusteIP service named kube-dns listen on port 53
- [[https://en.wikipedia.org/wiki/IP_Virtual_Server][IPVS (IP Virtual Server)]] is used

** Storage

- Container Storage Interface (CSI) provides a common interface for storage providers
- PersistentVolumes (PV), PersistentVolumeClaims (PVC), StorageClasses (SC)
- topology-aware provisioning is achieved when a PV is created only upon a Pod creation instead of before

*** Pod volumes
- Pod volumes okay for environment where a specific type of storage is needed (such as NFS), otherwise
  PersistentVolumes are used
- ~pod.spec.containers.volumeMounts~
- Common types are ~emptyDir~: ephemeral and host bound, ~hostPath~ persistent and host bound (security
  risks), ~PersistentVolumeClaim~, ~fc~ (fiber channel), ~isci~ etc.
*** Persistent Volumes
- a specific API resource that defines a storage
- pod connects to a PV by using a PVC: allow decoupling
- PV often created automatically with ~StorageClass~ resource

*** StorageClassName
  - Used to group different type of storage: preprod, prod, slow, etc.
*** StorageClass
- Works with a storage provisioner to create PV. Storage provisioner are not part of vanilla Kubernetes,
  provided by the ecosystem
*** PersistentVolumeClaims
Binds a storage without caring about its exact type. A PVC uses a ~storageClassName~ attribute, ~accessModes~
and ~resources~ (the size). The bound storage is exclusive so requesting 1G and being bound to a 10G storage
means the 10G storage is all used.

** ConfigMaps and secrets
ConfigMap is an API resource to store site specific information
- environment variables or files in a volume (or command-line arguments to the container)
- Up to 1M
- For configuration file, a Pod volume is necessary

Secret are base64 encoded. Types: generic (password), tls, docker-registry (for the credentials). The value
does not have to be stored in the application manifest file, so more secure but not encrypted!
~volumes.secret.defaultMode: 0400~.

For ~docker-registry~, use ~impagePullSecrets~ key.

** Kubernetes API

- general available (GA) resources that get deprecated are valid for 12 months or 3 releases before being
  phased out
- custom resources can be created with a custom controller, allowing to extend the Kubernetes API
- ~kubectl api-resources~, ~kubectl api-versions~
- ~kube-apiserver~ provides access to the API, the main client is ~kubectl~ (configured with ~~/.kube/config~)
- ~kube-proxy~ for secure communication, allow for example to url ~curl~ without setting up encryption
- A CustomResourceDefinition allows to add an API resource. crds are integrated with the Kubernetes API. No
  programming required to define it.
- Custom controller: watches for changes and automate tasks
- API aggregation: higher level of customization but needs to be programmed
- Operators are custom applications and based on Controllers, they are application-specific controllers
- Operators can be added by programming them or operatorhub.io. Ex: Prometheus, Tigera, Jaeger etc.
** Security

- authentification: client certificate or IAM solutions
- RBAC. Deny by default.
- Mutating and validating admission controllers: they intercept the requests
- ~kubectl auth can-i get pods --as bob@example.com~
- a custom ServiceAccount with RoleBinding can connect a Pod to a specific Role
- ~kubectl get sa~ (service account)
- RBAC: Role, ServiceAccount, RoleBinding. Role and RoleBinding: Namespace scope. ClusterRoles and
  ClusteRoleBinding have cluster scope
- ~kubectl create role NAME ...~, ~kubectl create sa NAME~, ~kubectm create rolebinding NAME ...~, ~kubectl
  set serviceaccount deployment DEPLOY NAME~
- ~kubectl describe clusterrolebindings.rbac.authorization.k8s.io system:coredns~
- ~kubectl describe clusterrole system:coredns~
- SecurityContext allow privilege escalation or extra capabilities, runAsNotRoolt, readOnlyFileSystem,
  runAsUser, seLinuxOptions etc.
- ~pod.spec.containers.resources.requests~ and ~pod.spec.containers.resources.limits~, ~kubectl set resources~
  to apply limits
** Security Hardening
- ~automountServiceAccountToken: false~ for pods that don't need to communicate with the API server
- Pod Security Standards (PSS): privileged, baseline or restricted. Implemented as validating admission controllers.
- ~kube-bench~

** Troubleshooting
- ~kubectl describe~ on a pod and check error code
- ~kubectl logs~, ~kubectl logs --previous~
- ~kubectl port-forward~
- ~kubectl get networkpolicies~
- ~kubectl get events -o wide~
- ~kubectl config view~

** Observability

- providing ~/healthz~, ~/livez~, ~/readyz~ endpoint is a common practice for applications (such as
  ~kube-apiserver~)
- probes: ~exec~, ~httpGet~, ~tcpSocket~
- probes types: ~livenessProbe~, ~readinessProbe~, ~startupProbe~

** Helm and Kustomize

~kubectl apply -k ./~. Can be used to create dev, staging, prod environments.

** Blue/Green and canary deployment
Blue-green: with either with Ingress or Deployments. For Ingress, change the service name. For Deployment,
expose only one of them, delete the other. Also possible with third-party solution.

For canary deployment, just a new version is exposed to a limited number of users. Can use
~nginx.ingress.kubernetes.io/canary~ and ~nginx.ingress.kubernetes.io/canary-weight~. Or with Services and set
a different number of replicas for the new service while testing.

* Commands
- ~kubectl api-resources~
- ~kubectl explain pod~, ~kubectl explain pod.specs~, ~kubectl explain pod.specs.container~, ~kubectl explain
  persistentvolume.spec~ etc.
- ~kubectl describe pod podname~
- ~kubectl create -f resource.yaml~ (fails if already exists), ~kubectl apply -f resource.yaml~
- ~kubectl delete -f resource.yaml~, ~kubectl replace -f resource.yaml~
- ~--dry-run=client -o yaml > file.yaml~ as argument to ~kubectl run~ or ~kubectl create~ to generate a YAML
  file
- ~kubectl get ... -A~ to see resources on all namespaces
- ~kubectl get pods -o wide~, ~kubectl get pods -o wide -A~
- ~kubectl get pods podname -o yaml~
- ~kubectl logs <podname>~
- ~kubectl exec -it podname sh~
- ~kubectl port-forward podname 8080:80~
- ~crictl ps~
- ~kubectl run dummy --image=busybox --dry-run=client -o yaml -- sleep infinity~
- ~kubectl cp <file> <pod>:<path>~
- ~kubectl create deploy webapp --image=nginx --replicas=3~
- ~kubectl get all --selector app=webapp~
- ~kubectl get all --show-labels~
- ~kubectl describe deployments.apps <label>~
- ~kubectl rollout history deployment <name> --revision=2~
- ~kubectl rollout undo deployment <name> --to-revision=<number>~
- ~kubectl get svc~
- ~kubectl get endpoints~
- ~kubectl lable pod NAME label=value~
- ~kubectl describe networkpolicy NAME~
- ~kubectl create ingress -h~
- ~kubectl describe in~
- ~kubectl get netpol -A~
- ~kubectl get ns~
- ~minikube addons enable ingress~
- ~kubectl create cm --from-literal key=value~
- ~kubectl create cm --from-env-file=filepath~
- ~kubectl set env~
- ~kubectl set env --from configmap/mycm deploy/mydeploy~, eventually with ~--prefix~
- ~kubectl expose deployment NAME --port=80 --type=NodePort~
- ~kubectl expose deployment NAME --port=80 --selector key=value --type=NodePort~
- ~kubectl proxy --port=8001~ then use ~curl~
- ~kubectl explain --recursive~
- ~kubectl port-forward myweb 8080:80~ then ~curl localhost:8080~
- ~kubectl get events -o wide~
* Components
Control plane:
- kube-apiserver (~kubectl~ command makes request to it)
- etcd
- kube-scheduler: schedule pods at specific locations
- kube-controller-manager: core processes
Worker nodes:
- container runtimes
- kubelet
* Solutions
** For on-premises
Google Anthos, Rancher, RedHat OpenShift, Canonical Kubernetes
** Locally
Minikube, K3s, OpenShift Local
